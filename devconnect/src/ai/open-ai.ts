import OpenAI from 'openai'
import fs from 'fs'
import path from 'path'
require('dotenv').config()
import { zodResponseFormat } from 'openai/helpers/zod'
import { z } from 'zod'
import { loadAndFormatCMS } from './format-content'
import { fetchFromSalesforce } from 'pages/destino'
import { createClient } from '@supabase/supabase-js'

const openai = new OpenAI({
  apiKey: process.env.OPEN_AI_KEY,
})

const CMS_PAGES_DIR = path.resolve(__dirname, '../../cms/pages')
const CMS_TRANSLATIONS_DIR = path.resolve(__dirname, '../../cms/global-translations')

const TranslationSchema = z.object({
  output: z.string(),
})

export const api = (() => {
  const _interface = {
    translateContent: async () => {
      // Translate both directories
      await translateDirectory(CMS_PAGES_DIR)
      await translateDirectory(CMS_TRANSLATIONS_DIR)
    },
    // Load CMS data and push to open ai - this is called by a github action triggered on each commit
    prepareContent: async () => {
      console.log('preparing content')

      await loadAndFormatCMS()

      const targetVectorStores = [
        `devconnect_website_${process.env.GITHUB_SHA}`,
        `devcon_website_${process.env.GITHUB_SHA}`,
        `devcon_app_${process.env.GITHUB_SHA}`,
      ]

      const attachContent = async (vectorStoreName: string) => {
        const vectorStores = await openai.beta.vectorStores.list()

        const vectorStore = vectorStores.data.find((store: any) => store.name === vectorStoreName)

        if (!vectorStore) {
          throw new Error(`Vector store not found: ${vectorStoreName}`)
        }

        const knowledgeBaseDirectory = path.resolve(__dirname, 'knowledge-base')
        const knowledgeBaseFiles = fs.readdirSync(knowledgeBaseDirectory)
        const knowledgeBaseStreams = knowledgeBaseFiles
          .map((filename: string) => {
            const filePath = path.join(knowledgeBaseDirectory, filename)
            // Skip directories, only process files
            if (fs.statSync(filePath).isDirectory()) {
              return null
            }
            // Create a stream with a custom filename prefix
            const stream = fs.createReadStream(filePath)
            return stream
          })
          .filter(Boolean) as any // Filter out null values (directories)

        const contentDir = path.resolve(__dirname, 'formatted-content')

        const files = fs.readdirSync(contentDir)

        const fileStreams = files
          .map((file: string) => {
            const filePath = path.join(contentDir, file)
            // Skip directories, only process files
            if (fs.statSync(filePath).isDirectory()) {
              return null
            }
            // Create a stream with a custom filename prefix
            const stream = fs.createReadStream(filePath)
            // stream.path = `devconnect_website_cms_file_${file}` // Override the filename in the stream
            return stream
          })
          .filter(Boolean) as any // Filter out null values (directories)

        // Upload files to vector store
        await openai.beta.vectorStores.fileBatches.uploadAndPoll(vectorStore.id, {
          files: [...fileStreams, ...knowledgeBaseStreams],
        })
      }

      for (const vectorStoreName of targetVectorStores) {
        await attachContent(vectorStoreName)
      }
    },
  }

  async function translateDirectory(sourceDir: string) {
    const allEntries = fs.readdirSync(sourceDir)
    const files = allEntries.filter(entry => fs.statSync(path.join(sourceDir, entry)).isFile())

    // Create translation directories if they don't exist
    const esDir = path.join(sourceDir, 'es')
    const ptDir = path.join(sourceDir, 'pt')

    if (!fs.existsSync(esDir)) {
      fs.mkdirSync(esDir, { recursive: true })
    }
    if (!fs.existsSync(ptDir)) {
      fs.mkdirSync(ptDir, { recursive: true })
    }

    for (const file of files) {
      const filePath = path.join(sourceDir, file)
      let content = fs.readFileSync(filePath, 'utf-8')

      let asJSON

      try {
        asJSON = JSON.parse(content)
      } catch (e) {
        asJSON = false
      }

      if (asJSON) {
        content = JSON.stringify(asJSON['global_translations'])
      }

      const spanishCompletion = await openai.beta.chat.completions.parse({
        temperature: 0,
        model: 'gpt-4.1',
        messages: [
          {
            role: 'system',
            content:
              'You take a file generated by our markdown based CMS and translate it to Spanish. Keep the exact same structure and formatting. I cannot emphasize this enough: Under no circumstances should your output have ANY structural differentation to the input. Do not include any other text or comments. Do not change or omit *any* field names, and do not translate any values for fields that start with an underscore - e.g. _template, _type, _id, etc.',
          },
          { role: 'user', content: content },
        ],
        response_format: zodResponseFormat(TranslationSchema, 'output'),
      })

      let { output: spanish } = spanishCompletion.choices[0].message.parsed as any

      const portugueseCompletion = await openai.beta.chat.completions.parse({
        temperature: 0,
        model: 'gpt-4o',
        messages: [
          {
            role: 'system',
            content:
              'You take a file generated by our markdown based CMS and translate it to Portuguese. Keep the exact same structure and formatting. I cannot emphasize this enough: Under no circumstances should your output have ANY structural differentation to the input. Do not include any other text or comments. Do not change or omit *any* field names, and do not translate any values for fields that start with an underscore - e.g. _template, _type, _id, etc.',
          },
          { role: 'user', content: content },
        ],
        response_format: zodResponseFormat(TranslationSchema, 'output'),
      })

      let { output: portuguese } = portugueseCompletion.choices[0].message.parsed as any

      if (asJSON) {
        spanish = JSON.stringify({
          global_translations: spanish,
        })

        portuguese = JSON.stringify({
          global_translations: portuguese,
        })
      }

      const spanishFilePath = path.join(sourceDir, `es/${file}`)
      fs.writeFileSync(spanishFilePath, spanish)

      const portugueseFilePath = path.join(sourceDir, `pt/${file}`)
      fs.writeFileSync(portugueseFilePath, portuguese)
    }
  }

  return _interface
})()

export const destinoEvents = (async () => {
  const EventSchema = z.object({
    en: z.string(),
    es: z.string(),
    pt: z.string(),
  })

  // Define a type for event records
  interface EventRecord {
    id: string
    event_id: string
    content: {
      en: string
      es: string
      pt: string
    }
    updated_at: string
    last_modified_at: string
  }

  // Initialize Supabase client once to reuse across functions
  const supabaseUrl = process.env.SUPABASE_URL || ''
  const supabaseKey = process.env.SUPABASE_KEY || ''
  const supabase = createClient(supabaseUrl, supabaseKey)

  const _interface = {
    getDestinoEvent: async (eventId: string) => {
      const { data, error } = await supabase.from('destino_events').select('*').eq('event_id', eventId).single()
      return data as EventRecord | null
    },
    generateDestinoEvent: async (event: any) => {
      // Check if event exists in Supabase with current version
      const { data, error } = await supabase.from('destino_events').select('*').eq('event_id', event.Id).single()

      const eventRecord = data as EventRecord | null

      // If exists and updated after last modification, return cached content
      if (eventRecord && new Date(eventRecord.updated_at) > new Date(event.LastModifiedDate)) {
        console.log(`Using cached content for event ${event.Id}`)
        return eventRecord.content
      }

      // Otherwise generate new content
      console.log(`Generating new content for event ${event.Id}`)

      const eventCompletion = await openai.beta.chat.completions.parse({
        temperature: 0,
        model: 'gpt-4.1',
        messages: [
          {
            role: 'system',
            content:
              'You take an event object and generate a simple summary of it in English, Spanish and Portuguese. It will be used on a website to advertise the event.',
          },
          { role: 'user', content: JSON.stringify({ ...event, description: '' }) },
        ],
        response_format: zodResponseFormat(EventSchema, 'summary'),
      })

      const content = eventCompletion.choices[0].message.parsed as { en: string; es: string; pt: string }

      // Save to Supabase
      await supabase.from('destino_events').upsert({
        event_id: event.Id,
        content,
        updated_at: new Date().toISOString(),
        last_modified_at: event.LastModifiedDate,
      })

      return content
    },
    generateDestinoEvents: async () => {
      const apiUrl = 'https://ef-esp.lightning.force.com/lightning/o/Lead/list?filterName=PGR_Destino_Devconnect'
      const events = await fetchFromSalesforce(apiUrl)

      const results = await Promise.all(
        events.map(async (event: any) => {
          const content = await _interface.generateDestinoEvent(event)
          return { event, content }
        })
      )

      return results
    },
  }

  return _interface
})()

export default api
